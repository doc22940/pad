
- To do
    - Think about supporting the entire project at once.
        - Pad is always editing exactly one project.
        - Project is defined by .git or whatever (Makefile, build.xml, pom.xml, etc.).
            - Or explicit.
            - Ignore known sub-trees (.git, dist, target) and files (binary files, backups).
        - Everything done to entire project (search, etc.).
        - Can keep several files open and unsaved at once.
        - Can see which files are unsaved in file browser.
        - Can save one or all files.
        - Each pane assigned to one file.
        - Bookmarks (mx and 'x) go to specific file and location.
        - Questions:
            - Does this imply that the file browser should always be full-height?
            - Do I really want split window? I never really use it. IDEs don't have it.
        - Simplification proposal:
            - No split screen with multiple source files.
            - Four panes ever:
                - Source pane in middle.
                - Command pane on bottom.
                - File/search/error browser on right.
                - Gutter pane on left.
        - UI:
            - Load pad without specifying filename.
            - Show empty pane and file browser on right.
            - Browser has full tree.
            - Ctrl-O opens file browser.
                - Ctrl-O again shows opened files (highlighting unsaved ones).
                - Ctrl-O again closes it.
            - Ctrl-S switches to previous file.
                - Is it possible to get Ctrl-S?
        - Data model:
            - Doc:
                - Represents a file on disk.
                - Has scroll from top.
                - Has cursor X/Y.
                - Has file type.
                - Has undo/redo history.
                - Modified status.
            - Pane:
                - Represents rectangular area of screen.
                - Concrete implementation has:
                    - Key bindings.
                    - Way to get layout.
            - Directory:
                - Hash from filename to either Directory or Doc.
                - Read on load, and updated immediately because of watch.
        - To do:
            - Implement Directory.
            - Use it in file browser.
            - Make sure file browser has no doc, only layout.
    - Support ".".
        - Each action stores itself in a field.
        - Could be a function to call.
        - Insert would have to be created on ESC.
        - Might be easier to have object with command and content.
        - Insert would create one with empty string, which is extended with
          every character and null'ed out when the arrow keys are pressed.
    - Every class should have start() and stop() methods (or whatever) to register and
        unregister listeners.
    - Think about wrapped lines where the wrapping doesn't happen on a space.
        - What does it mean to go to the end of the line ($)?
        - Same as the end of the file when there's no eol there.
    - Warn when quitting without saving.
        - Add quit override (:q!).
- Research
    - go-oracle: https://docs.google.com/document/d/1SLk36YRjjMgKqe490mSRzOPYEDe0Y_WQNRv-EiFYUyw/view
    - Play with Brackets to get ideas and look through code.
        - How do they implement the editor?
        - How do they do syntax highlighting?
- Architecture
    - JavaScript in Node.js.
    - When loading file:
        - Load plugin based on file type (based on extension or magic number).
        - Plugin determines:
            - Buffer type (line-based, byte array).
            - View type (plain text, code, etc.).
    - Powerful plugin system.
        - Specify plugins in config file.
        - Automatically downloaded.
        - Can stick themselves in various places (including documentation).
        - Plugins hook in to extension points and define their own extension points.
    - Mostly done by exposing an API and implementing plugins that call the API.
        - E.g., API for moving cursor to any location, then write plugin to
          move to the right, then write another plugin to bind it to "l" key.
    - Use Command pattern to execute commands.
        - Supports undo/redo, logging, queuing, and simulation.
    - Have concept of main pane with side panes.
        - Documents can only be split horizontally. They're always full-width of the window.
        - Left pane always scrolls with main pane. For errors, breakpoints, etc.
        - Right pane can scroll, or not. For file tree, errors, hints, documentation, etc.
        - Main pane has pointers to sub-panes and vice-versa.
        - Easy to close side pane.
        - Pane itself resizes and moves, to make it easy. But window knows what's what
            and can calculate original size based on which side panes are open.
        - Side panes cannot have side panes.
    - Objects:
        - Window
            - Responsible for managing panes.
            - The whole terminal window.
            - Later could be multiple terminal windows.
        - Buffer
            - Responsible for returning information about the file and modifying the file.
            - Stores array of lines for file.
            - Also stores whether last line has newline.
            - Whether modified.
            - Undo/redo history.
            - Listeners can be told when any part of it changes.
        - Pane
            - Responsible for tracking what's visible in a pane.
            - Rectangle on screen.
            - Responsible for showing the buffer and interpreting commands to modify it.
            - Points to layout.
            - Line and column offset.
            - Cursor location.
            - Keymaps, plugins, etc.
                - Presumably these are actually tied to the buffer.
                - But not necessarily, could be interesting to have two views of same buffer.
            - Listens to changes in buffer and updates the pane contents.
        - Layout
            - Actual layout of lines on screen.
            - Array of lines. Each line has:
                - Rich/annotated text
                - Virtual indent
                - Line/column of buffer.
                - Need to also not allow cursor in middle of tab.
                    - Can use annotation for that.
                - For annotation, vim uses 16 bits if syntax highlighting, 8 otherwise.
            - Probably cache info from formatter or buffer, either global or per-line.
        - Formatter
            - Converts a buffer to a layout.
            - Can do incremental updates.
            - Multiple implementations.
            - Mostly stateless.
- Questions
    - How to deal with UTF-8 characters in layout?
        - Vim has 8-bit array of whole screen.
        - Also keeps parallel 32-bit array, which is 0 if the 8-bit value should be used.
        - Parallel array of 16-bit attributes.
        - Array index by line that specifies index in above three arrays.
    - Should we use streaming (event-based) or non-streaming (read-based) reading
        from stdin? If event-based, we don't have any control over when the keys
        are handled. If read-based, we could have a main loop that reads one
        character at a time in a controlled way.
- Plugins
    - See how done in Emacs
    - See how done in jEdit: http://www.jedit.org/
- Simplify
    - Only support UTF-8.
        - Or only support ASCII?
    - Only support VT-220 (or whatever).
    - Only support terminal mode, not GUI.
    - Only support small files (source code, documents).
    - Lines and columns are always 0-based.
- Wacky ideas
    - A .pad file at top of project explicitly specifies project root and
        project parameters, like file types, etc.
    - Don't edit file, edit project.
        - Can just run "pad" and it restores last project session (files edited, locations,
            searches, etc.)
        - When first on project, open file tree pane.
    - Serve web page to show more info on what's being edited in real time.
    - Serve web page of the HTML being edited right now. Update in real time.
        - Ditto with: Markdown, pixel shader, WebGL, Processing.JS, charts, etc.
        - Live view follows cursor.
    - As you're editing HTML/CSS, the changes are pushed to the browser without requiring
        reload. See brackets.io.
    - Periodically save state of all panes and buffers. If process is killed, offer
        a way to restore it all, like Chrome does with tabs.
    - Use iTerm2-specific escape codes.
        - Check $TERM_PROGRAM.
        - https://code.google.com/p/iterm2/wiki/ProprietaryEscapeCodes
    - Easy way to see commit message of blame of line you're on, and maybe history before that.
    - When entering a single-line comment and Enter is pressed, continue comment if
        line didn't finish with a period. Or just never press Enter and wrap the text
        automatically, with a virtual // at the front.
- Nice things
    - When typing pathname of file to load, correct errors.
    - When typing pathname of file to create, create directories (with permission).
        - Highlight new sections as the user is typing.
    - If loaded file has no LF on last line, save it that way.
    - When pasting, detect that characters are coming in too quickly and disable auto-indent.
    - Automatic visual line wrap with syntax-aware indent.
    - Auto-indent on paste (mouse paste or regular paste).
- Reference
    - crowley98data.pdf in Downloads (compares buffer implementations).
    - Command line parsing: https://www.npmjs.org/package/commander
    - ANSI:
        - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
        - http://www.xfree86.org/current/ctlseqs.html
        - https://en.wikipedia.org/wiki/ANSI_escape_code
- Competition
    - TextMate 2
        - Mac GUI.
        - Pretty simple, but nicely done. Beautiful colors.
        - Lots of support for languages, SCMs, etc.
        - Can run the program and get output easily (or errors).
        - Skimmed code (~/others/textmate). Hard to follow. Not much there.
    - Emacs
        - http://www.chrismennie.ca/EMACS-Conceptual-Architecture.pdf
            - Not a whole lot of interest. Internal buffer, display buffer.
        - http://www.gnu.org/software/emacs/emacs-paper.html
            - By RMS. Didn't read.
        - http://www.finseth.com/craft/index.html
        - 1.1m lines of Lisp.
        - Buy "Beautiful Architecture" or subscribe to O'Reilly thing, or borrow from Markos.
        - http://www.xemacs.org/Documentation/21.5/html/internals.html
        - Buffers have marks (single point) and extents (pair of marks and properties)
            that move around with the text.
        - http://www.chrismennie.ca/EMACS-Conceptual-Architecture.pdf
    - jEdit
        - http://www.jedit.org/api/index.html
        - Uses gap buffer internally. (Array of char.)
    - vim
    - sam
        - http://plan9.bell-labs.com/sys/doc/sam/sam.html
    - Bracket.
    - Ace
        - http://ace.c9.io/#nav=about
- Community
    - Website for plugins.
    - Could we just use "npm install" like grunt does?
- Random
    - Keep a parallel array of attributes for highlighting and other things. Otherwise
        we have to run algorithms to figure out the color constantly, and this will
        restrict what we can do.
        - Could implement this by using a wide char and using high bits for attributes.
        - Instead of parallel array, keep a list of indexes where the attributes change.
    - Can we follow MVC for once? What would that mean?
        - In Emacs the Controller is mostly Lisp, taking keystrokes and modifying
            the model. The View displays the Model, but I guess this isn't Lispable?
    - Proper support for mixed languages, like JS in HTML.
        - That means that things like key bindings, indent, and color must be
            to a region, not a buffer.  So instead of (say) setting a key
            binding when starting to edit a buffer, we must match each part of
            a buffer to a language, and dynamically dispatch to the key binding
            when typing in that region of the buffer.
    - Each plugin exports a set of help pages. Each page has a name, one-line description,
        and page. Can search help, or just descriptions (apropos), or maybe
        have permuted index.
    - Help written in markdown.
    - Space to left of code is called "gutter". Line numbers, errors, other info.
    - Ability to do math, like a spreadsheet.
    - For JS linting:
        - http://eslint.org/


Archived
--------

- Name
    - "pad" (notepad, textpad, editpad)
        - This is the winner.
    - "edit" (ultraedit)
    - dlite (sounds like lite version of something)
    - From Brad: Modal, Alice, Milo, Alden, Vitamin, Caffeine
    - punch, pnch
