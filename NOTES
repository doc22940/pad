
- To do
    - Have concept of main pane with side panes.
        - Left pane always scrolls with main pane. For errors, breakpoints, etc.
        - Right pane can scroll, or not. For file tree, errors, hints, documentation, etc.
        - Main pane has pointers to sub-panes and vice-versa.
        - Easy to close side pane.
        - Pane itself resizes and moves, to make it easy. But window knows what's what
            and can calculate original size based on which side panes are open.
        - Side panes cannot have side panes.
        - Assume only horizontal splits across main panes. Vertical splits are always
            secondary panes.
    - Every class should have start() and stop() methods (or whatever) to register and
        unregister listeners.
    - Think about wrapped lines where the wrapping doesn't happen on a space.
        - What does it mean to go to the end of the line ($)?
        - Same as the end of the file when there's no eol there.
    - Play with Brackets to get ideas and look through code.
        - How do they implement the editor?
        - How do they do syntax highlighting?
    - Warn when quitting without saving.
- Architecture
    - JavaScript in Node.js.
    - When loading file:
        - Load plugin based on file type (based on extension or magic number).
        - Plugin determines:
            - Buffer type (line-based, byte array).
            - View type (plain text, code, etc.).
    - Powerful plugin system.
        - Specify plugins in config file.
        - Automatically downloaded.
        - Can stick themselves in various places (including documentation).
        - Plugins hook in to extension points and define their own extension points.
    - Mostly done by exposing an API and implementing plugins that call the API.
        - E.g., API for moving cursor to any location, then write plugin to
          move to the right, then write another plugin to bind it to "l" key.
    - Use Command pattern to execute commands.
        - Supports undo/redo, logging, queuing, and simulation.
    - Objects:
        - Window
            - Responsible for managing panes.
            - The whole terminal window.
            - Later could be multiple terminal windows.
        - Buffer
            - Responsible for returning information about the file and modifying the file.
            - Stores array of lines for file.
            - Also stores whether last line has newline.
            - Whether modified.
            - Undo/redo history.
            - Listeners can be told when any part of it changes.
        - Pane
            - Responsible for tracking what's visible in a pane.
            - Rectangle on screen.
            - Responsible for showing the buffer and interpreting commands to modify it.
            - Points to layout.
            - Line and column offset.
            - Cursor location.
            - Keymaps, plugins, etc.
                - Presumably these are actually tied to the buffer.
                - But not necessarily, could be interesting to have two views of same buffer.
            - Listens to changes in buffer and updates the pane contents.
        - Layout
            - Actual layout of lines on screen.
            - Array of lines. Each line has:
                - Rich/annotated text
                - Virtual indent
                - Line/column of buffer.
                - Need to also not allow cursor in middle of tab.
                    - Can use annotation for that.
                - For annotation, vim uses 16 bits if syntax highlighting, 8 otherwise.
            - Probably cache info from formatter or buffer, either global or per-line.
        - Formatter
            - Converts a buffer to a layout.
            - Can do incremental updates.
            - Multiple implementations.
            - Mostly stateless.
- Questions
    - How to deal with UTF-8 characters in layout?
        - Vim has 8-bit array of whole screen.
        - Also keeps parallel 32-bit array, which is 0 if the 8-bit value should be used.
        - Parallel array of 16-bit attributes.
        - Array index by line that specifies index in above three arrays.
    - Should we use streaming (event-based) or non-streaming (read-based) reading
        from stdin? If event-based, we don't have any control over when the keys
        are handled. If read-based, we could have a main loop that reads one
        character at a time in a controlled way.
- Plugins
    - See how done in Emacs
    - See how done in jEdit: http://www.jedit.org/
- Simplify
    - Only support UTF-8.
        - Or only support ASCII?
    - Only support VT-220 (or whatever).
    - Only support terminal mode, not GUI.
    - Only support small files (source code, documents).
    - Lines and columns are always 0-based.
- Wacky ideas
    - Serve web page to show more info on what's being edited in real time.
    - Serve web page of the HTML being edited right now. Update in real time.
        - Ditto with: Markdown, pixel shader, WebGL, Processing.JS, charts, etc.
        - Live view follows cursor.
    - Make available as web app. Not sure how node's module system ports over.
        - http://browserify.org/
            - Wouldn't allow run-time plugins. It's all bundled into one file.
    - Periodically save state of all tiles and buffers. If process is killed, offer
        a way to restore it all, like Chrome does with tabs.
    - As you're editing HTML/CSS, the changes are pushed to the browser without requiring
        reload. See brackets.io.
    - Use iTerm2-specific escape codes.
        - Check $TERM_PROGRAM.
        - https://code.google.com/p/iterm2/wiki/ProprietaryEscapeCodes
    - Easy way to see commit message of blame of line you're on, and maybe history before that.
- Nice things
    - When typing pathname of file to load, correct errors.
    - When typing pathname of file to create, create directories (with permission).
    - If loaded file has no LF on last line, save it that way.
    - When pasting, detect that characters are coming in too quickly and disable auto-indent.
    - Automatic visual line wrap with syntax-aware indent.
    - Auto-indent on paste (mouse paste or regular paste).
- Reference
    - crowley98data.pdf in Downloads (compares buffer implementations).
    - Command line parsing: https://www.npmjs.org/package/commander
- Competition
    - TextMate 2
        - Mac GUI.
        - Pretty simple, but nicely done. Beautiful colors.
        - Lots of support for languages, SCMs, etc.
        - Can run the program and get output easily (or errors).
        - Skimmed code (~/others/textmate). Hard to follow. Not much there.
    - Emacs
        - http://www.chrismennie.ca/EMACS-Conceptual-Architecture.pdf
            - Not a whole lot of interest. Internal buffer, display buffer.
        - http://www.gnu.org/software/emacs/emacs-paper.html
            - By RMS. Didn't read.
        - http://www.finseth.com/craft/index.html
        - 1.1m lines of Lisp.
        - Buy "Beautiful Architecture" or subscribe to O'Reilly thing, or borrow from Markos.
        - http://www.xemacs.org/Documentation/21.5/html/internals.html
        - Buffers have marks (single point) and extents (pair of marks and properties)
            that move around with the text.
        - http://www.chrismennie.ca/EMACS-Conceptual-Architecture.pdf
    - jEdit
        - http://www.jedit.org/api/index.html
        - Uses gap buffer internally. (Array of char.)
    - vim
    - sam
        - http://plan9.bell-labs.com/sys/doc/sam/sam.html
    - Bracket.
- Community
    - Website for plugins.
    - Could we just use "npm install" like grunt does?
- Random
    - Keep a parallel array of attributes for highlighting and other things. Otherwise
        we have to run algorithms to figure out the color constantly, and this will
        restrict what we can do.
        - Could implement this by using a wide char and using high bits for attributes.
        - Instead of parallel array, keep a list of indexes where the attributes change.
    - Can we follow MVC for once? What would that mean?
        - In Emacs the Controller is mostly Lisp, taking keystrokes and modifying
            the model. The View displays the Model, but I guess this isn't Lispable?
    - Proper support for mixed languages, like JS in HTML.
        - That means that things like key bindings, indent, and color must be
            to a region, not a buffer.  So instead of (say) setting a key
            binding when starting to edit a buffer, we must match each part of
            a buffer to a language, and dynamically dispatch to the key binding
            when typing in that region of the buffer.
    - Each plugin exports a set of help pages. Each page has a name, one-line description,
        and page. Can search help, or just descriptions (apropos), or maybe
        have permuted index.
    - Help written in markdown.
    - Space to left of code is called "gutter". Line numbers, errors, other info.
    - Line up/down should always be in visual lines, not buffer lines.
    - Ability to do math, like a spreadsheet.
    - For JS linting:
        - http://eslint.org/


Archived
--------

- Name
    - "pad" (notepad, textpad, editpad)
        - This is the winner.
    - "edit" (ultraedit)
    - dlite (sounds like lite version of something)
    - From Brad: Modal, Alice, Milo, Alden, Vitamin, Caffeine
    - punch, pnch
